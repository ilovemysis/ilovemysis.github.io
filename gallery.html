<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

                <style>

            @import url('https://fonts.googleapis.com/css2?family=Satisfy&display=swap');
            body {
                background-size: cover;
                background-position: center;
                background-repeat: no-repeat;
                font-family: 'Satisfy', cursive;
                font-weight: 400;
                font-style: normal;
                background-color: #fdc9df;
                color: #333;
                text-align: center;
                padding: 10px 20px;
                margin: 0;
                height: 100%;
                overflow-x: hidden;
                font-size: 22px; /* Large font for easy reading */
            }

            .hasi-container {
                width: 100%; /* Full width of the container */
                text-align: center; /* Center the image horizontally */
                margin: 0 0; /* Provide some spacing above and below */
            }

            .hasi-container img {
                width: 150px; /* Maintain the original image width */
                height: auto; /* Maintain the original image height */
            }

            .satisfy-regular {
                font-family: 'Satisfy', cursive;
                font-weight: 400;
                font-style: normal;
            }

            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                font-family: 'Satisfy', cursive;
                font-weight: 400;
                font-style: normal;
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                font-family: 'Satisfy', cursive;
                font-weight: 400;
                font-style: normal;
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #d6336c;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #d6336c;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #ffebee;
                font-family: 'Satisfy', cursive;
                font-weight: 400;
                font-style: normal;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>

    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Gallerie ist nur f√ºr V.I.P</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="LET ME IN" />
                        <p id="responseText">nur Melissa darf das Passwort weitergeben!</p>
                    </form>
                </div>
            </div>
        </div>
    </head>
        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d26f2287c03311f89f17f05d8730bf5c42180466f87d319dca1ddcbb8890cd397e1fec15ff72a1cd3a6c8c87ad5ba77537c9d3f5d5381a0816e40bc28a1518bc446126f52e6d492d432a90240182f939441b575991146d2e380a6a66ed5b970cbf5e587e3e479a687febfb4b117bfb80f565210fe71abe8939e9d424fffbb736a5514ca353e012c23db0560fb84ee4cd94251c42d788e1f92391565ad451fec9c62f4b2013ad97003259dac0de6efa790809d7cf919bd3655741615bf5bf9d4b958eed39d5bf33e80cafc764801c5a2be444669b83e1376aad0e8beaa56a7efe973a6ecfe1c47ea919deae00435cad8a03450e37df4efb072c9ee861f0a8f4ced659a2764c3e62506dec9b574358c56cd4f4c7ae2a5fa37f195fcc64e336e68e3ac8c02452005d99d32b980365169bcc24188647e89e61da3657cf2074f40c73ce7cea042425aabda69882273650815eaca25ceeb891464887692ff6637518c96e8ac0478a5885b55c8ca059fbb797715a4054cba1d6d051e4c266b1822e0995250f682d7f6be571bb166fee5f29d2e2dba4c588d256e8158ceba084d93d677e4eb2a78c0851d96fedc75fa2a6dfd68788a8916a8501c4ae5d5d9976da6ab482ddc1ac75646b5e4bdef29b842a013bb5d8117dcf3ba817200780743e3695bc558a710b4209748605c100d88ada3c59757e092d1a08669022daeebb01285409a7f6fa6d37336d7a16221724c772dd15b8f118ff046301192b504a522f84dafa625486c0e75cfef0a2cd2c6b720a269d892090ae2c9faaf4fb8894b90df65d70da465b37c7da42004532f40423012fe8a1dc0b87a562dfa43e9e7489eeb4b605fa6aeafa9306e381210c15234725cb2eabdae20c1460814896c1c1bef3841a32ced5797d4ddc1486259b04d13b8e231d001c95d936fdec7a836ac9958e1d8ebe618f426bed770d2b8667052258f88f49ce7aa7a91e618e941e32be46c84090a4533b924917ab15453db26a5aa9cb525851f3098b0d36b8e9ca41968bb8d87e553162c98e4cf79000d576bcc8e377d1dbff44b2654cb7bb9a99e5540e0db4ca0e3218db0f363aedab140c3159884824e3d4cfc85f3a1ad6bee71185dd38f05b28b5c1f784d342f3d8ab92bf58503b6cb4f81674d9300de09be9237c3bfb8b511131f1fe1e1d72af765fa7dd1774722fa313d2db45ef4091c0ab93e0aa6f50279340fb2bd02f15f982484c5decfbe5eff6c9ff9654ba745a53dcbb288a661ddf61db7da5cf7318291fd71415762e8c2918ae844f73b3d41decbb1c2cce3aa26c7c18fc11e4655e55c55cf70b56789a4104ca2a21baf3de0ee8d9127406052bcbff13de617e045042cd928b303646d314e625fcd9fd6b458f53ffabc42926974067e79d3e4625b99f3ecdce493e1cb50308d16d6ae5c209c635d5c06175e7ec98ec979081c058fe6a54eb382718331265fa13df9603c090d876ce50ceb4656111a74dac95e8c89bf0abdb4241fd89856f4370e1d138edf771eaae0d5456f12fb500b7c1aa789b8cfbda3e496579bbad16e7c68e34fd5b93d58e47d1733d80438324db54f1f276ed3cc686c85c9af92211880bc94563454c297904a54dd6e824d4bf202824bfb91070446946b30190ea2122287c5819d8c91189c279590f469712a5b27155349db3748b88e1142a207c5f8e84959a61803a53cc23dc80581e1f0d317963e34250eaac0699b8991c1f2d190a50ae12853715e19ddefe70b25ade574d656f1c39582bbf3245f9dce143620c95b8604cac65746f01104ce4b475c1473d4c92824493974ac4da7c446568b7faa4f07a509aa8e547234d3d5fc059bb4f0823911de28a8b3b736d284eb6b483145f1d25c029c57fe18215dc4c8e703afdf84eee229367dc27e89ff4a2706e291c569d0eac432c8df4522a3ac5e644c8fbbeb4d11504c818774f0cd425f2f96b089bd86798cbb8d20d442b7efed79ad5157079475998615e0d04eb5ad2970a86467ea91c5d59e99109f2ceb6897d504bcd610340032dab7c3f28727422233cef9fcbc4ea788d71d4bfe57de5a0edc833b64c8a9a3759c76808d412ce99778734cc0fb811e9e7a0cf49c3b6508939598a2ca49b77531be7ddfa98f097318c5ad91b8416f6d5ac41c8d9825083d7b690488c2057754e23d09c3ee1fcf14d8d9e2228cf9083fe7b8c5e858e717f44f646836adb74c2dac2c9a6dd08a1fecafdf7144bbfdf1709e8882953784eb3d5e6e6a35f6418f7104e72db47cb58f5bca574ce1cdb3e78ca4364387cf99b61eaf804e63b1076b5e345f98c97be89d2a0a5c38d271de5b4fa6ef945aeda7cf476e0c7e41f66f84d5e4e13d1b8704102cfe98d9c66b45a44ebc3d0682bd5a27ef81c89206cb0950890a480d8100f74fd3b9b74a79cb104ca9f61b6bcecd6ffce507bf318724a08ea2a53c9881130fb15890b48c1079ccbce1b646fcb1f49af41855572cf3a63621e50c03f939bd1ba6ea72de5b85a929b059f112ff8be95c7c55bd028a5e412c2b1cf687b987859daabbfd9cc1403fa2ea6f38ee31dea353422787ada33c269acb99da76dab90b8a45ab9d4c76dd0eaea7fe1689eccad0e511748dfcbb6d16abe81945cf2394add6de777cc07aa4391247bfa18d7a53308282d759e3b1e23e7197f16c7b879af6632b2e11ff0de597c4a616ce1b93aad8207935f50d1255c2440d936c9b08633dda3eb925023b2712883c695d72d0196e9947f2eb9e45ac695a829d1bf720d7f7dacb13d6a63d636ab7f49504735c3ff2302be9750c80ece34afb104b8b5a9008b5922998ca5aebb8b9675876889fe0c2fee22e98015225a4d0578a4883a8202ff0ec210ab14102b1af9b7105841b3a0f03d174c8b1608a6a03b490332ced668fc7c2ac64da728bb8a7a390fd69d99271a7e63755e8da926f6ab9ba32582534688460dfdd51090535e4435c8df268eb445409f9c74fc3b9fbce2a8ef556686273c96230e582839454bde6e437b6e8861ea56da6773f4097093c02849a3e81d922846de952829f038ce84d9ec71dc441861f186cbd782680efaf8af55826b0a890f4cbd94243577384b79a3dc16d162a293efd3b1f937fd65c778f50c150d3295c7845e23bb6eda82676badf7f89c041e466f7ad41337064cb7d5df88a4866faa0caac43a32a0b33f99a025dd76b9a691e3e9c85168211e59637710c184abcdd5bbe1221db1ef91ed28913b40a22ee1f9799627ee1543ea3ff6189905e7344033ea059208b211463e4b88d9925552a6ca2c09a01b029d63f23ab02c4ae6058e70685185af253f5a88dc9995260a728b274defb0841d7f13c0c39c301a9cf27533ec620c745b1d7343a7546e85d643fc3e0c916922c4e7f27e6084488b6c84d7fc32085a2cc3baffa4a3f21b4bd8471a8bc7f55fe96e81c01543253a28bc2c0c1190382c3d22acd1ee19d5a37496f12c701cf1cf62e2979dbf04c324acd98b874f68465108baab1914a4ca77818669c67830b1c5c34aac001c03a24e843956f494e99a9fca8961ea6ee3e0d4116c15415d6e850e9617130d4bf5004ef29014f6c189f9c7e49dd74bb3075261450ebc89bc95e02fb79cebc9daae364dfa289a8ba9d2f8d9292f78c5fccabd84890822691a2086a8ef002ef612b9eefe2d4a2d66602d01f540b62c57913eaa2874412400cdbd65b6e07329229adf5d34b9fddbf72ed8f9551bda3f0200a7c40d08c9c60d07cfc17bedaf4dd13385493717dec66bc5513be1844e29f81957bc22930400c3a66118ad4cc392966347f805943e1bd2ef95513e995c1216badef1540e8bf8ee73a7207c51171e95e6e786df3c711629b2a13542f7ad746af84689ffcecc7b552fc45c3aab096ec3bc0fe6b1bbc29a7890f0e14f9b87b8d31ee15f7a5ada476e70a480987b41a186cab9166c0a470359c74067f0d385d7e720f52a0fc8f04a90fc9e0d2460853656550c645bab0d49679a59c713dc124efe5d457c9f9358cf41863e3658ecce1dcf3fd3de0d1707591feffc35c07ac49e0dc15beb817467c57a61a6c258e749d41083d850381925404f553bfa271cd06a3d67ea27c6dda257014b8bd0dfd726dbc38c9b1105a81f2b03f77fd55592a64d6a2e6dae6e7f9d3c88e0095ac0a7a43f4e96f8f04a4a81b4ebab54c5be940c200d807109b4534a7d75fae061921719c8e53f76d6124d8d5adb3b2128232953354e59455100a805edbad2cf7d3d7c7d75e40e4f724b4a64db8bb7a7382dbd61a3ed1a3bfd9859f34263c18afa50b5a4e2e7fbbec897d1f8660ad9a53da0f7ac863eab260918734ad1f6673a7dc453c4d5e785f731763e19a12cfc55e69050f64d4933eba333933bbb706fbb1bbb7d2476001cec36b128b8ade54b2de1d5507c81469bc8cbb9e9a50c68dfc3ca12bf5f12b0cd41fa7f2393ce37408d1fbefbf0b344ed300670c63a5c7fd202feec5bc2d7881780a5b52b15f6701f9579f6cb2d882644dd5d8b6f396a2704589d57e3b635ea99b3dae36db8730ab72ddd63e7fbee18e0ef37e1edff152eb178cbf2da65ed1d62883dc17d819692464b594faa75d144471327d6c18b71cc911347f66be07c8e27b4f5c2c2c65b46edbadfa89de0f1b7ea164308f408420cac829a4aa48795998837b7821e5c9a36961f5e14d58cda9e846c49970388625c74db22f630f142bb365c75bd9fa152d6917a098df5c95f75fd38c27a10024dedc56713a63c592f2f80e408ee6481273ff95219e622218899e025e6d6004d508f66b434f660a9a3418a287196df3c59cf71989c2ed4a6d9e447b6356727d475d951a073a5467eb367b0c20c44ef47c071b766e89e49eac76a561277b9b1283fcd27ef2d0054eb90520400110a4654276d3e60a152ee2449722a254cc6116343d1cad2674204105b30708f095186785c78f5d00c49643432725e6a71bb757b86fa9e44d38d579c5afb18952f3658ff510b601e8d5ca37c22361c50a3662d980a0777ce00524914662ec222243645cc38f3400433a86f8b35517ed198ff75ae875a59ce87887183225055eafdd9cb07b71f1adab0bcddb1957d3c51be848089acda288ab9c5d002fbf005ff00659858497cff673e10cfde4ddc55dd2f7270a82cb38f6c4cc02e639f608cd0b97c05620510361cf4edb8b817a8b6796d41122605e3b810e2557d808b375e171d81b1ce2bde642f566d9897abf4a45ffefe7c0547155d7c74bbff1097b0556cb32bbf82ee2852ebe4f6c98703a401921bdcdc92adf09a807392e9919514c29ed6ed51952bce32db7307b901c7d503f0d6e873dd93d77fa47988e5beb655eff52be77306a96fdd7270e315ddbffdca9d0f42c36c7909ec98e69c77125aadee64c3398c9c54216d4acf1802a3b0145da679432123448fcfa1f98b1d330880b14a8a1717e271cc20edfa64ff8b9f2a6f1c8f0bfcd9f31aea45e20a24774520f75a69bfcd76f690d9e6208db1f58ba9d7cbc283782f171eab11eba4e71dc1ef4f4439bbd262fee325776510bd35f665368efd7526f39190506100e7c9a353d30960668fbdf07a6319f403149c8c965cf9b7e7aed0996de4a0c44dac0a9a31c93c85be03126193aa18c7577696d92b76c594d39e847296f2a92ee5c114d8cb0298c9027a385b9e777919fd7bd418b9f76583c1d4663a7630b13465849cff3039eb683cabb56cdb1895018de0156b2bef402c62bee1b3b1e870b4c0eabdb3ed62d89f56d29f17ac2c3bd72473e9614675670a92b1abd4ff132b3f657447538952e3727a43d6a65b4d2b34fa2d8ee473f7de2c83ba37a2e5d37af4136051645224fff908daac456bf7e27c0f95fe0f9f7cb24c84f9f74d8e051badc9d589356f4662f524da2560a367ff651cd9f518b37aa8c7fd78c57174cac9f3ee86b32ddc2003a5ae6be8b3b83e3e92eb34b94e87037f400f3a35453c2a6078b41ca3220e53ae66d494cad8367331cd03bd057a3833abbef6b029b3ac55bf81ac67f38e026422acdf820fcfa3f905c09a232f3df8356ab30df100fcbaf39b66690dc4f4dd2f8aef1b4fb61dc8fcaffaab7a6b584b83bd3e4ac6bf2cceb491c4eff39176965b4f5263200d2bf41639f809ccdd9b4e92739da9617f71785c10b6a1974667f4fcf166ca7a2b6e363a079042ee5b92957c1d2346562a171d00f044d93b192c7cfb32633c922dbef45e0f46fc2cd8d7698a4d202765d44606b4dcf72ca53d7bc72dfef5194d59cf3a6a891c83c20c6b7ea0f21dbe9f1feb89336d92d5087c265531f8ec47773f439fe8261051d224560becc01a2e5bb3114cd4fe72a67a6d472144c2eb100d51cf73e76dccee21bce4501f6e94ac3e62951abf29aaf096705f349cf057451270667ddadc5b0acf1dca4c4fc67aa188f98d8bf678dab2808b52b7c53adcf00e357d428b50e3db2bfe2ca5313bf9250e6ac39c7d95a751cb7e423a265d54de54bab978da1e9da4e7a5e373a360c1532ad023f32271b22208df5f93a08a71765e39930d2fb4e0719166d40a5aa1d3a6c58d17e75bac14f9edcbc8457885d6c3c22e8d9fbc20fa24adfa91b2de803d8635db665fecff4c1f6c0511a0d51400118265aa6d36e4a94c83b3b82432ce223f5ef99ee8ac6ec1d05053944965a97997df59a6566ae7caeef475dc64a18fdb676737d661f571b54ff9fa08e911fc40415217e40b9475699a0c1b7b8664cca9766d867c43d4a90e76b823d7dcb49e29cde71b827ddb696a57a26cd216601e9744e0df640ff8bbed48a9a4ae00da8cdb3206410053b6baa3c6e2df4f45e7de067576aa571d071c89179b11636c9d6d9b7915084236849e997e1b0c20c76cb1e5dda83a1199b055fd207252ef5e05205162b45a753f922550304153d7c7c6caeafcf2fa2e4f74930820e76e40a18ec3ee5a73b6756411da19c7a2a2c136f3bf435b8c07045051dee790a265c595017a8ab7c58f7a168f9c54bdd04562ea04e2f456063f39b210a7276b3f0c5f3b73bf430475c9a64d659b381974cc7e6035c5d9ddd3120938b5904821f72262b31488c9a6d8ba4a714a39fee4fe9892a2cf7b866f3ff554a489e54efbe7b1bface218b1a7214c36faa84786454f6704f3bd632ba1bcf18d563b6c8e0c5b609518498338e6e649ac9453a129459b3fb4aed31fb99e6884ba6508b848e269ddb440b8b5c7b564656a6c56abdb9a170e7340f31da43ccb2b86ef23f1ba14fa755da8ced9355b71ed04818d3d4a793bebca094f5ec376b93e11fd2c77dc235e8ecef48f726d6425c14aaa457f2ddc55179461ecb1c1fb16518726c1b62d048784714a9b6b3195ea14fb72aad7b1610195effcfd1f5e61e25b88deaa9e8c7fbb5c6afde81354075908a206b79e0bd4b017b01de3d95efb592c5f53e473e9ca6bab90fb1947de3669e15f0d76c010a4ad4fd4b7630a677c1cec9877c03ea07e0b060e4410b35ae5f014e41fa102bf8012420a4f1ec755e3d91d4e616e6b28a6274cdabe4b7c5ffbc97d5271dd0181caf5196fa770416aa4fc81fd15c68075571bfe53c7f93e5e306d27f5571e2c653909232e49f2a5349755260001235a4d2983b586ddaf416b85ce6dcbe8111489554b9a12788f8e1d3bfffe05f49e177196ffd1a8f372156c0f611a469725e1e10ff264bc5a0cfa01bc0767be8882c1bf6512fa8d5c76834bc2c58b8700a4544e45a30061cc560c44a63334b5991911aabe7a649a2783b98218f94ab47ab158fc08272ef611488953253b3f572d4f72332772d5472129bca05ae72742190af9df07ba7165849fdfcc624f25c14ddc15e5d45c963dbea93a5a9e1876c3822f89bb9bef80fb337e781975a6a5e7ba75b4540b704c73be5cb883226dca6a9de721896ce9729f6a39ebcc5e9f1f81f65bdc923aba8ec1b089244d4219cb8585fff74e8b2a47ad60690c208b67fe51c0e2a12aaa41ceead6dade34eb8af950fb034f40051832a28d95c1b02551bd2b59e56a0337886c9e5a4cf17ebebfb64efd891722d4691ab8612b98bbab6c0011111c2fe052dee7216e8bc9d2f512aebcdc9b195b5ba597aa9179f581b285ad2b34409c0afc66fcdc403c49e3b31ac606bd9cfb8b256aab01e37629dc46916ae4d6748ddd77f3dc2d011d903c6d0034cb9d27e37429b1dee047e70539a20fa10988a7f425b39ba97892b914ae35eef718a550ec59ed6d89958ec8e2446b094924d1fea650db69b0cc3fef8be342ae8c7d30cd9c349dc8e15b84f9abfd823e7552f902c1b5e5611c90545391f599dc35bdad023e22ae2031bbf194d4c8ef1386482b223fa8d12670714b6ff4f402b976dedb6f10dd4cbcf01f326e363f803c1f8be43975acf46a6054c6aba3cc461d999dadf4c666dccc236140553756de52be43fd4979e0e247b210a4bb61e2ee57d8b5414145eee40302157cd474a5f18e181c15e190c004e963729be6faffaf222566c804b3c0fe737ac6e981d7c14a5d57f8b29ec00f24f7b2f5ea335214267abc8ffbf568048a30104826cd081618863c94631da876e4943717a4b46ed65a0c771b4d7798a581972b76ee15e39c63cd4381306abe88fbf47f5e396d9e3250dafd024879c865caf63ea83196569204781842a3d6c59a8f2aed2232b3fc9c48b47aae4dc4e2f18876b1183e4faf54f0f69c877138d0ab1141f839bd3cf4bba929c7310e31db9169134eef858e8b18a5842dd41328b3f567e3c1f5d8cbe3a0aa83d9211d26fc9dbe4b2b2d7bb3f7dbb4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"42a07a88fc700f83378f6307c8aead4e"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
